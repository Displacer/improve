module Language.ImProve.Code (code) where

import Control.Monad.State
import Data.List
import Data.Maybe
import Text.Printf

import Language.ImProve.Core
import Language.ImProve.Tree hiding (Branch)
import qualified Language.ImProve.Tree as T

-- | Generate C and Simulink code.
code :: Name -> Statement -> IO ()
code name stmt = do
  writeFile (name ++ ".c") $
       "/* Generated by ImProve. */\n\n"
    ++ "#include <assert.h>\n\n"
    ++ codeVariables True scope ++ "\n"
    ++ "void " ++ name ++ "()\n{\n"
    ++ indent (codeStmt name [] stmt)
    ++ "}\n\n"
  writeFile (name ++ ".h") $
       "/* Generated by ImProve. */\n\n"
    ++ codeVariables False scope ++ "\n"
    ++ "void " ++ name ++ "(void);\n\n"
  codeMdl name stmt >>= writeFile (name ++ ".mdl")
  where
  scope = case tree (\ (_, path, _) -> path) $ stmtVars stmt of
    [] -> error "program contains no useful statements"
    a  -> T.Branch (name ++ "_variables") a

instance Show Statement where show = codeStmt "none" []

codeStmt :: Name -> [Name] -> Statement -> String
codeStmt name path a = case a of
  Assign a b -> name ++ "_variables." ++ pathName a ++ " = " ++ codeExpr b ++ ";\n"
  Branch a b Null -> "if (" ++ codeExpr a ++ ") {\n" ++ indent (codeStmt name path b) ++ "}\n"
  Branch a b c    -> "if (" ++ codeExpr a ++ ") {\n" ++ indent (codeStmt name path b) ++ "}\nelse {\n" ++ indent (codeStmt name path c) ++ "}\n"
  Sequence a b -> codeStmt name path a ++ codeStmt name path b
  Theorem _ _ _ a -> "assert((" ++ show (intercalate "." path) ++ ", " ++ codeExpr a ++ "));\n"
  Assume a -> "assert((" ++ show (intercalate "." path) ++ ", " ++ codeExpr a ++ "));\n"
  Label name' a -> "/*" ++ name' ++ "*/\n" ++ indent (codeStmt name (path ++ [name']) a)
  Null -> ""
  where

  codeExpr :: E a -> String
  codeExpr a = case a of
    Ref a     -> name ++ "_variables." ++ pathName a
    Const a   -> showConst $ const' a
    Add a b   -> group [codeExpr a, "+", codeExpr b]
    Sub a b   -> group [codeExpr a, "-", codeExpr b]
    Mul a b   -> group [codeExpr a, "*", showConst (const' b)]
    Div a b   -> group [codeExpr a, "/", showConst (const' b)]
    Mod a b   -> group [codeExpr a, "%", showConst (const' b)]
    Not a     -> group ["!", codeExpr a]
    And a b   -> group [codeExpr a, "&&",  codeExpr b]
    Or  a b   -> group [codeExpr a, "||",  codeExpr b]
    Eq  a b   -> group [codeExpr a, "==",  codeExpr b]
    Lt  a b   -> group [codeExpr a, "<",   codeExpr b]
    Gt  a b   -> group [codeExpr a, ">",   codeExpr b]
    Le  a b   -> group [codeExpr a, "<=",  codeExpr b]
    Ge  a b   -> group [codeExpr a, ">=",  codeExpr b]
    Mux a b c -> group [codeExpr a, "?", codeExpr b, ":", codeExpr c] 
    where
    group :: [String] -> String
    group a = "(" ++ intercalate " " a ++ ")"

indent :: String -> String
indent = unlines . map ("\t" ++) . lines

indent' :: String -> String
indent' a = case lines a of
  [] -> []
  (a:b) -> a ++ "\n" ++ indent (unlines b)

codeVariables :: Bool -> (Tree Name (Bool, Path, Const)) -> String
codeVariables define a = (if define then "" else "extern ") ++ init (init (f1 a)) ++ (if define then " =\n    " ++ f2 a else "") ++ ";\n"
  where
  f1 a = case a of
    T.Branch name items -> "struct {  /* " ++ name ++ " */\n" ++ indent (concatMap f1 items) ++ "} " ++ name ++ ";\n"
    Leaf name (input, _, init) -> printf "%-5s %-25s;%s\n" (showConstType init) name (if input then "  /* input */" else "")

  f2 a = case a of
    T.Branch name items -> indent' $ "{   " ++ (intercalate ",   " $ map f2 items) ++ "}  /* " ++ name ++ " */\n"
    Leaf name (_, _, init) -> printf "%-15s  /* %s */\n" (showConst init) name

showConst :: Const -> String
showConst a = case a of
  Bool  True  -> "1"
  Bool  False -> "0"
  Int   a     -> show a
  Float a     -> show a

showConstType :: Const -> String
showConstType a = case a of
  Bool  _ -> "int"
  Int   _ -> "int"
  Float _ -> "float"


type Net = StateT Netlist IO

data Block
  = Inport    Const
  | Outport   Const
  | UnitDelay Const
  | Switch

data Netlist = Netlist
  { nextId :: Int
  , vars   :: [Path]
  , env    :: [Name]
  , blocks :: [(Name, Block)]
  , nets   :: [(Name, (Name, Int))]
  }

-- Simulink generation.
codeMdl :: Name -> Statement -> IO String
codeMdl name stmt = do
  net <- execStateT (mapM_ input vars >> elaborate stmt >> mapM_ output vars) (Netlist 0 paths env [] [])
  return ""
  where
  vars = stmtVars stmt
  paths = [ path | (_, path, _) <- vars ]
  env = [ error $ "variable " ++ pathName a ++ " does not have a source" | a <- vars ]

  input :: VarInfo -> Net ()
  input (input, path, const) = do
    a <- if input then block' (pathName path) (Inport const) else block $ UnitDelay const
    updateEnv path a
  
  output :: VarInfo -> Net ()
  output (True, _, _) = return ()
  output (False, path, const) = do
    a <- block' (pathName path) $ Outport const
    src <- getNet path
    net src (a, 0)

-- A switch block.
switch :: Name -> Name -> Name -> Net Name
switch a b c = do
  name <- block Switch
  net a (name, 0)
  net b (name, 1)
  net c (name, 2)
  return name

newName :: Net Name
newName = do
  net <- get
  put net { nextId = nextId net + 1 }
  return $ "b" ++ show (nextId net)

-- New unnamed block.
block :: Block -> Net Name
block a = do
  name <- newName
  modify $ \ net -> net { blocks = (name, a) : blocks net }
  return name

-- New named block.
block' :: Name -> Block -> Net Name
block' name a = do
  modify $ \ net -> net { blocks = (name, a) : blocks net }
  return name

-- New net.
net :: Name -> (Name, Int) -> Net ()
net src (dest, port) = modify $ \ net -> net { nets = (src, (dest, port)) : nets net }

updateEnv :: Path -> Name -> Net ()
updateEnv path name = do
  net <- get
  let i = fromJust $ elemIndex path $ vars net
      pre = take i $ env net
      post = drop (i + 1) $ env net
  put net { env = pre ++ [name] ++ post }

getNet :: Path -> Net Name
getNet path = do
  net <- get
  return $ env net !! (fromJust $ elemIndex path $ vars net)


-- Elaborate netlist.
elaborate :: Statement -> Net ()
elaborate a = case a of 

  Assign (V _ path _) b -> do
    b <- evalExpr b
    updateEnv path b

  Branch a b c -> do
    cond <- evalExpr a
    net0 <- get

    elaborate b
    net1 <- get
    modify $ \ net -> net { env = env net0 }

    elaborate c
    net2 <- get
    modify $ \ net -> net { env = env net0 }

    names <- mergeEnvs cond (env net1) (env net2)
    modify $ \ net -> net { env = names }

    where

    mergeEnvs :: Name -> [Name] -> [Name] -> Net [Name]
    mergeEnvs _ [] [] = return []
    mergeEnvs cond (a : as) (b : bs) = do
      names <- mergeEnvs cond as bs
      name <- if a == b then return a else switch cond a b
      return $ name : names
    mergeEnvs _ _ _ = error "unbalanced environments"

  Sequence a b    -> elaborate a >> elaborate b
  Theorem _ _ _ _ -> return ()
  Assume _        -> return ()
  Label _ a       -> elaborate a
  Null            -> return ()

evalExpr :: E a -> Net Name
evalExpr a = return "" --XXX

