module Language.ImProve.Code
  ( code
  , Scope (..)
  ) where

import Data.List
import Text.Printf

import Language.ImProve.Core

-- | Generate C code.
code :: Name -> Statement -> Scope -> IO ()
code name stmt scope = do
  writeFile (name ++ ".c") $
       "// Generated by ImProve.\n\n"
    ++ "#include <assert.h>\n\n"
    ++ codeVariables True scope ++ "\n"
    ++ "void " ++ name ++ "() {\n"
    ++ indent (codeStmt stmt)
    ++ "}\n\n"
  writeFile (name ++ ".h") $
       "// Generated by ImProve.\n\n"
    ++ codeVariables False scope ++ "\n"
    ++ "void " ++ name ++ "(void);\n\n"

varName :: V a -> String
varName a = intercalate "." names
  where
  names = case a of
    V   names _ -> names
    VIn names   -> names

codeStmt :: Statement -> String
codeStmt a = case a of
  AssignBool  a b -> varName a ++ " = " ++ codeExpr b ++ ";\n"
  AssignInt   a b -> varName a ++ " = " ++ codeExpr b ++ ";\n"
  AssignFloat a b -> varName a ++ " = " ++ codeExpr b ++ ";\n"
  Branch a b Null -> "if (" ++ codeExpr a ++ ") {\n" ++ indent (codeStmt b) ++ "}\n"
  Branch a b c    -> "if (" ++ codeExpr a ++ ") {\n" ++ indent (codeStmt b) ++ "}\nelse {\n" ++ indent (codeStmt c) ++ "}\n"
  Sequence a b -> codeStmt a ++ codeStmt b
  Assert names a -> "// assert " ++ intercalate "." names ++ "\nassert(" ++ codeExpr a ++ ");\n"
  Assume names a -> "// assume " ++ intercalate "." names ++ "\nassert(" ++ codeExpr a ++ ");\n"
  Null -> ""

codeExpr :: E a -> String
codeExpr a = case a of
  Ref a -> varName a
  Const a -> showConst a
  Add a b -> group [codeExpr a, "+", codeExpr b]
  Sub a b -> group [codeExpr a, "-", codeExpr b]
  Mul a b -> group [codeExpr a, "*", showConst b]
  Div a b -> group [codeExpr a, "/", showConst b]
  Mod a b -> group [codeExpr a, "%", showConst b]
  Not a   -> group ["!", codeExpr a]
  And a b -> group [codeExpr a, "&&",  codeExpr b]
  Or  a b -> group [codeExpr a, "||",  codeExpr b]
  Eq  a b -> group [codeExpr a, "==",  codeExpr b]
  Lt  a b -> group [codeExpr a, "<",   codeExpr b]
  Gt  a b -> group [codeExpr a, ">",   codeExpr b]
  Le  a b -> group [codeExpr a, "<=",  codeExpr b]
  Ge  a b -> group [codeExpr a, ">=",  codeExpr b]
  Mux a b c -> group [codeExpr a, "?", codeExpr b, ":", codeExpr c] 
  where
  group :: [String] -> String
  group a = "(" ++ intercalate " " a ++ ")"

indent :: String -> String
indent = unlines . map ("  " ++) . lines

indent' :: String -> String
indent' a = case lines a of
  [] -> []
  (a:b) -> a ++ "\n" ++ indent (unlines b)

data Scope
  = Scope Name [Scope]
  | Variable Bool Name String String  -- input name type init
  deriving Eq

instance Ord Scope where
  compare a b = case (a, b) of
    (Scope a _, Scope b _) -> compare a b
    (Variable _ a _ _, Variable _ b _ _) -> compare a b
    (Variable _ _ _ _, Scope _ _) -> LT
    (Scope _ _, Variable _ _ _ _) -> GT

codeVariables :: Bool -> Scope -> String
codeVariables define a = (if define then "" else "extern ") ++ init (init (f1 a)) ++ (if define then " =\n  " ++ f2 a else "") ++ ";\n"
  where
  f1 a = case a of
    Scope     name items -> "struct {  // " ++ name ++ "\n" ++ indent (concatMap f1 $ sort items) ++ "} " ++ name ++ ";\n"
    Variable  input name typ _ -> printf "%-5s %-25s;%s\n" typ name (if input then "  // input" else "")

  f2 a = case a of
    Scope    name items -> indent' $ "{ " ++ (intercalate ", " $ map f2 $ sort items) ++ "}  // " ++ name ++ "\n"
    Variable _ name _ init -> printf "%-15s  // %s\n" init name

